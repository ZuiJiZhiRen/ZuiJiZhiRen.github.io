<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>spring源码解析笔记一</title>
      <link href="/2018/11/23/springOrigin/SpringOrigin1/"/>
      <url>/2018/11/23/springOrigin/SpringOrigin1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jvm学习笔记二</title>
      <link href="/2018/11/21/jvm/jvm2/"/>
      <url>/2018/11/21/jvm/jvm2/</url>
      
        <content type="html"><![CDATA[<p>学习书籍<strong>深入理解Java虚拟机_JVM高级特性与最佳实践+第2版_220</strong></p><p>如何写出更加优秀代码？</p><h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><p>java程序员有一个共识，以编译方式执行本地代码比解释方式更快，之所以有这样的共识，出了虚拟机解释执行字节码时额外消耗时间外，还有一个重要的的原因是虚拟机团队几乎把对代码的所有优化措施都集中在了即时编译器之中。<br>具体细节大家自己看看《深入理解Java虚拟机》</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><strong>较为严谨的定义</strong>：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象时线程安全的。</p><ol><li>java语言中的线程安全：按照安全程度，由强至弱来排序，我们可以将java语言中的跟中操作共享数据分为以下五类<ul><li><strong>不可变</strong>：final修饰的数据类型,String数据类型（字符放入常量池中）等，在多线程中不会因线程的交替而产生变化。</li><li><strong>绝对线程安全</strong>：比如Vector,它得add(),get(),size()都是被synchronized修饰的，尽管效率很低，但是确实是安全的。</li><li><strong>相对线程安全</strong>：是我们通常意义上所讲的线程安全，它需要确保对这个对象单独操作是线程安全的。</li><li><strong>线程兼容</strong>：对象本身并不是线程安全的，但是可以通过在正确的使用同步手段来保证对象在并发环境中可以安全的使用。</li><li><strong>线程对立</strong>：无法进行线程并发。</li></ul></li><li>线程安全的实现方法：<ul><li><strong>互斥同步</strong></li><li><strong>非阻塞同步</strong></li><li><strong>无同步方案</strong></li><li><strong>可重入代码</strong></li><li><strong>线程本地存储</strong></li></ul></li></ol><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ol><li><strong>自旋锁与自适应自旋</strong>：线程的上下玩切换时非常消耗时间，如果我们让线程等待一下，在进行尝试获取锁，这样我们就可以避免了线程切换的开销，当然这会占用处理器的时间。所以等待多久进行尝试获取锁需要慎重取值，不过后来出现了自适应自旋对自旋时间进行了一个很好的处理。具体呢就是根据概率，概率是根据同一个锁获取成功概率进行判断。</li><li><strong>锁消除</strong>：锁消除是指虚拟机及时编译器在运行时，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。根据<strong>逃逸分析</strong>处理。</li><li><strong>锁粗化</strong>:如果一个没有并发的操作，但是操作比较复杂，每一个小操作都上了锁，则会导致效率很低。那现在只要在第一个小操作和最后一个小操作进行加锁，则提升了效率。</li><li><strong>轻量级锁</strong>：</li><li><strong>偏向锁</strong></li></ol><h2 id="短暂的总结"><a href="#短暂的总结" class="headerlink" title="短暂的总结"></a>短暂的总结</h2>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysqlStudy</title>
      <link href="/2018/11/20/mysqlStudy/mysqlStudy/"/>
      <url>/2018/11/20/mysqlStudy/mysqlStudy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>23中设计模式学习</title>
      <link href="/2018/11/20/designpattern/designPattern/"/>
      <url>/2018/11/20/designpattern/designPattern/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>博主的个人感想</title>
      <link href="/2018/11/20/index/"/>
      <url>/2018/11/20/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> index </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>算法学习记录</title>
      <link href="/2018/11/20/math/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/11/20/math/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>每天看一点，多年以后或许就是不一样的自己了。</p><ol><li><a href="/2018/11/20/math/二分法的一些bug和实现">二分法的一些bug和实现</a></li><li><a href="/2018/11/20/math/十大经典排序算法">十大经典排序算法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据结构学习记录</title>
      <link href="/2018/11/20/struct/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/11/20/struct/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>学习博客<a href="http://blog.jobbole.com/111680/#article-comment" target="_blank" rel="noopener">http://blog.jobbole.com/111680/#article-comment</a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>从百度百科搂过来的定义<br>数据结构定义：数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。</p><h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><p>一.数据的逻辑结构：指反映数据元素之间的逻辑关系的数据结构，其中的逻辑关系是指数据元素之间的前后件关系，而与他们在计算机中的存储位置无关。逻辑结构包括：</p><ol><li>集合<br>数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系；</li><li>线性结构<br>数据结构中的元素存在一对一的相互关系；</li><li>树形结构<br>数据结构中的元素存在一对多的相互关系；</li><li>图形结构<br>数据结构中的元素存在多对多的相互关系；</li></ol><p>我们在学习java中，对线性结构，树形结构应该都是很熟悉的。我们想想那些地方用到了线性结构和树形结构。很显然在集合的数据结构很多，有队列，红黑树，链表，数组。。。。<br>不过这里和话主要对树结构进行相对详细的总结，主要是树结构在查询方面有着很高的效率，应用也是很广泛。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>十大经典排序算法</title>
      <link href="/2018/11/20/math/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/11/20/math/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>参考博客<a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html</a><br>一些概念性的以及自己偷懒的行为，很多都是直接粘过来，防止以后博客关了找不到了，我这边自己做一个备份，不过代码实现还是自己实现的，跟参考博客会有不同。</p><p>##十大排序算法可以分为两类##</p><ol><li>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</li><li>线性时间非比较排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 </li></ol><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</span><br><span class="line"></span><br><span class="line">不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</span><br><span class="line"></span><br><span class="line">时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</span><br><span class="line"></span><br><span class="line">空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</span><br></pre></td></tr></table></figure><h2 id="十大算法"><a href="#十大算法" class="headerlink" title="十大算法"></a>十大算法</h2><p><img src="https://wuzhiwen.oss-cn-beijing.aliyuncs.com/sortclass.png" alt=""><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">图片来源</a><br><img src="https://wuzhiwen.oss-cn-beijing.aliyuncs.com/sortsynale.png" alt=""><br><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">图片来源</a></p><h3 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h3><p>冒泡是最基本的算法，原理我就不说了，自己百度吧<br>代码实现</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Auther: wuzhiwen</span><br><span class="line"> * @Date: 2018/11/13 16:58</span><br><span class="line"> * @Description:冒泡排序</span><br><span class="line"> */</span><br><span class="line">public class MaoPaoSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">//        int[] arraySort = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">//        int[] arraySort = &#123;1,2,3,4,5,6,10,8,9,7&#125;;</span><br><span class="line">        long l = System.currentTimeMillis();</span><br><span class="line">//        int[] arraySort = &#123;8,3,4,5,6,7,1,2,0,9&#125;;</span><br><span class="line">//        int[] arraySort = &#123;8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7,8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7,8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7,8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7,8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7,8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7,8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7,8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7,8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7,8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7&#125;;</span><br><span class="line">//        int[] arraySort = &#123;8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 8, 3, 4, 5, 6, 7, 1, 2, 0, 9, 1, 2, 3, 4, 5, 6, 7&#125;;</span><br><span class="line">        int[] arraySort = &#123;</span><br><span class="line">                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 500, 491, 492, 493, 494, 495, 496, 497, 498, 499</span><br><span class="line">        &#125;;</span><br><span class="line">        bubbleSort(arraySort);</span><br><span class="line">//        maopaoSort(arraySort);</span><br><span class="line">        long l1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(l1 - l);</span><br><span class="line">        for (int j : arraySort) &#123;</span><br><span class="line">            System.out.print(j + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //输出数组长度</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(arraySort.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 冒泡排序写的太复杂了,效率也不是很好</span><br><span class="line">     * 很是尴尬</span><br><span class="line">     *</span><br><span class="line">     * @param arraySort</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int[] maopaoSort(int[] arraySort) &#123;</span><br><span class="line">        int sortLength = arraySort.length;</span><br><span class="line">        while (sortLength &gt; 0) &#123;</span><br><span class="line">            int temp = arraySort[0];</span><br><span class="line">            boolean k = true;</span><br><span class="line">            for (int j = 1; j &lt; sortLength; j++) &#123;</span><br><span class="line">                if (temp &gt; arraySort[j]) &#123;</span><br><span class="line">                    arraySort[j - 1] = arraySort[j];</span><br><span class="line">                    arraySort[j] = temp;</span><br><span class="line">                    k=false;</span><br><span class="line">                &#125; else if (temp &lt; arraySort[j]) &#123;</span><br><span class="line">                    temp = arraySort[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (k) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            sortLength--;</span><br><span class="line">        &#125;</span><br><span class="line">        return arraySort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 简洁的写法</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int[] bubbleSort(int[] arr) &#123;</span><br><span class="line">        int len = arr.length;</span><br><span class="line">        for (int i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">            boolean k = true;</span><br><span class="line">            for (int j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                    int temp = arr[j + 1];        // 元素交换</span><br><span class="line">                    arr[j + 1] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                    k = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (k) &#123;</span><br><span class="line">                return arr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>我想起我一次面试，让我写一个冒泡算法，我写好后，他问我如果我的数组是已经排序好的，再用冒泡排序，如何做一些优化？我当时年轻紧张啊，就是想不起来，后来面试结束后在回去的路上想起了了，做一个判断，如果一次内循环一直没有走进if判断，那就说明没有进行置换，那说明就是这个数组是已经排序好的，同时我们可以再做一次优化如果整体中只有个别数据进行了调换，那么我们加一下这样的判断不是可以提高查询效率吗，当然，如果我们的数据全是乱的，那也会导致查询效率降低，所以只能根据具体的数选择相应的优化了。代码中对这些都进行了测试，效率差距不是很大，如果数据再扩大十倍，效果就会很明显，大家可以自己试试。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>找到最小的把它放在前面就行了。<br><br><strong>代码实现</strong></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Auther: wuzhiwen</span><br><span class="line"> * @Date: 2018/11/14 13:26</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arraySort = &#123;8,3,4,5,6,7,1,2,0,9&#125;;</span><br><span class="line">//        quicksort(arraySort);</span><br><span class="line">        quicksort2(arraySort);</span><br><span class="line">        for (int j : arraySort) &#123;</span><br><span class="line">            System.out.print(j + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 虽然是完成了排序，但是效率以及简洁性都是很差的</span><br><span class="line">     * 不得不承认自己的思维很是有些复杂了，或者说是简单了</span><br><span class="line">     * @param array</span><br><span class="line">     */</span><br><span class="line">    public static void quicksort(int[] array) &#123;</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            int temp = array[i];</span><br><span class="line">            int index = -1;</span><br><span class="line">            for ( int i1 = i; i1 &lt; array.length; i1++) &#123;</span><br><span class="line">                if (temp &gt; array[i1]) &#123;</span><br><span class="line">                    temp = array[i1];</span><br><span class="line">                    index = i1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (index != -1) &#123;</span><br><span class="line">                array[index] = array[i];</span><br><span class="line">                array[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 优化代码实现</span><br><span class="line">     * @param array</span><br><span class="line">     */</span><br><span class="line">    public static void quicksort2(int[] array) &#123;</span><br><span class="line"></span><br><span class="line">        int temp;</span><br><span class="line">        //这里减一，最后一个不用再比较了</span><br><span class="line">        for (int i = 0; i &lt; array.length - 1; i++) &#123;</span><br><span class="line">            int minIndex = i;</span><br><span class="line">            //不需要跟自己比较了</span><br><span class="line">            for(int j = i+1 ;j &lt;array.length; j++)&#123;</span><br><span class="line">                if(array[j] &lt; array[minIndex])&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = array[minIndex];</span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jvm学习笔记一</title>
      <link href="/2018/11/20/jvm/jvm1/"/>
      <url>/2018/11/20/jvm/jvm1/</url>
      
        <content type="html"><![CDATA[<p>学习书籍<strong>深入理解Java虚拟机_JVM高级特性与最佳实践+第2版_220</strong></p><h2 id="jvm-jdk-jre"><a href="#jvm-jdk-jre" class="headerlink" title="jvm,jdk,jre"></a>jvm,jdk,jre</h2><ol><li><p>jvm(java virtual machine)是java虚拟机英文缩写，它是java可以跨平台的最为重要的核心。主要作用的是解析.class文件解释成cpu能够执行的指令集（字节码）。</p></li><li><p>Jre(java runtime environment)是JRE是指java运行环境，jre里面包含两个文件，一个是lib,一个是bin,我们可以认为bin就是jvm,lib就是jvm工作所需要的类库。</p></li><li><p>Jdk(java development kit),安装了jdk后我们可以看见jdk文件中有六个文件夹，其中最重要是四个文件bin、include、lib、jre。</p><ul><li>bin:最主要的是编译器(javac.exe)</li><li>include:java和JVM交互用的头文件</li><li>lib：类库</li><li>jre:java运行环境。</li></ul></li></ol><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>类的加载过程有七个步骤，</p><ol><li><p>加载：加载是类加载的一个阶段，我们粗略的可以分为三个阶段<br> 1)我们通过类的全限定名获取该类的二进制字节流。<br> 2)将该字节流的静态存储结构转换为方法区中运行时数据结构。<br> 3)在内存中生成该类的一个java.lang.Class对象，作为方法区中该类各中数据的访问入口。</p></li><li><p>验证：它的主要目的是为了确保Class文件的字节流包含信息符合jvm的要求，并且不会危害jvm本身。总体来说它的验证包含四个。<br> 1)文件格式验证：<br> 2)元数据验证：<br> 3)字节码校验：<br> 4)符号引用验证：</p></li><li><p>准备：准备阶段是类为变量分配内存和初始值的阶段，这些变量使用的内存都将在方法区中进行分配。这里有两个模糊的点，一个是为类的变量分配内存仅仅是为类变量（被static修饰的变量），而不包括实例变量，实例变量是跟着类实例化时进行分配的。另一个是这里初始值一般是设置该数据类型的零值。假设public static int a = 123,则初始化时a=0。上面说到一般设置为零值，但是如果被设置为ConstantValue例如public static final int a = 123,那么在准备阶段就会被设置为123。</p></li><li><p>解析：解析阶段是将常量池中符号引用替换为直接引用的过程。详细的请自己百度。</p></li><li><p>初始化：实例化和初始化呢是有区别的，我们不能搞混了。初始化阶段就是执行类构造器<clinit>方法的过程，jvm会先调用父类的<clinit>方法，接口也会有<clinit>方法，但是不会初始化父类的<clinit>方法，只有当父类定义的变量使用时，才会调用父类的<clinit>方法。<strong><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态代码块static{}中的语句合并产生的，其中编译器收集的顺序是由语句在源文件中出现的顺序所决定。而且一个类只会被初始化一次，但是可以实例化多次。</clinit></strong>实例化是将类完全加载到内存中后创建对象的过程。实例化的初始化顺序是先实例变量初始化，在实例代码块初始化，最后构造函数初始化。但是所有类的实例化都是先实例化超类，实例化一个类，必须先实例化它的父类，而超类是任何类的父类，所以实例化一个类相当于递归的查找最顶层的父类，然后依次实例化。</clinit></clinit></clinit></clinit></clinit></p></li><li><p>使用：</p></li><li><p>卸载：。。。</p></li></ol><h2 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h2><ol><li>什么是类加载器：通过类的全限定名来获取描述此类的二进制字节流，这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何获取所需的类。实现这个动作的代码模块被称之为“类加载器”。</li><li>类与类加载器：不同的类加载器加载同一个类，它们必然不相等，equals(),isInstance()。。。使用instanceof用不同的类加载器加载同一个类是不同所属。</li><li>类加载器分类：<ul><li>启动类加载器：</li><li>扩展类加载器：</li><li>应用程序类加载器：</li></ul></li><li>类加载器的两个模型：<ul><li>双亲委派模型：就是先一层一层的找到类加载器的父类，如果父类不能加载，则找下面的子类进行加载，当然也是一层一层的进行的。</li><li>破坏双亲委派模型：。。。OSGI,比较复杂自己百度。</li></ul></li></ol><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>了解GC,那就需要先了解GC中常用的算法。</p><h3 id="GC中的算法分类"><a href="#GC中的算法分类" class="headerlink" title="GC中的算法分类"></a>GC中的算法分类</h3><ul><li><strong>引用计数算法</strong>：给对象添加一个计数器，每当有一个地方引用它时，计数器加一；当引用失效时，计数器就减一；任何时刻计数器为0的对象就是不可能再被使用的。这是一个不错的算法，但是在主流的jvm虚拟机中没有实现这样的算法，原因是无法解决相互引用出现的问题。</li><li><strong>可达性分析算法</strong>：基本思想是通过一系列称为“GC-Roots”的对象作为起始点，从这些起始点向下搜索，搜索所走过的路称为引用链，当一个对象到“GC-Roots”没有任何引用链相连时，则证明此对象不可用。<br>  那些可以作为“GC-Roots”的对象？<ol><li>虚拟机栈中引用表</li><li>方法区中的静态属性引用对象</li><li>方法区中常量引用对象</li><li>本地方法中的JNI引用对象（native方法）</li></ol></li><li><strong>标记-清除算法</strong>： 此算法顾名思义，该算法中标记和清除效率都不高，而且清除的内存碎片由于不连续，如果存放大的对象则会导致没有内存存放，进而触发垃圾回收。</li><li><strong>复制算法</strong>：先将内存一分为二，只有一半存放数据，当开始清理内存的时候，将需要的数据复制到另一半内存中，然后统一将另一半清理，这样不会存在碎片了。而且效率也高，就是代价太高了，需要一半的内存空着。</li><li><strong>标记-整理算法</strong>：在清理内存的数据的时候，将需要的数据移动到一起，剩下的不需要的则删除。</li><li><strong>分代收集算法</strong>：根据对象存活周期，分配不同的内存以及使用适合的收集算法。</li></ul><h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><ul><li><strong>serial收集器</strong>：<ol><li>线程：单线程</li><li>算法：复制算法</li><li>回收位置：回收新生代的数据</li><li>使用原因：效率高，运行在client端效率依旧很好。</li></ol></li><li><strong>parnew收集器</strong>：<ol><li>线程：多线程，相当于多个serial</li><li>算法：复制算法</li><li>回收位置：回收新生代的数据</li><li>使用原因：可以与cms收集器配合使用，运行在server端是比较合适的。</li></ol></li><li><strong>parallel scavenge收集器</strong>:<ol><li>线程：多线程</li><li>算法：复制算法</li><li>回收位置：回收新生代的数据</li><li>使用原因：关注与吞吐量，有自适应调节机制。</li></ol></li><li><strong>serial old收集器</strong>:<ol><li>线程：单线程</li><li>算法：标记-整理算法</li><li>回收位置：回收老生代的数据</li><li>使用原因：关注与吞吐量，有自适应调节机制。</li></ol></li><li><strong>paraller old收集器</strong>:<ol><li>线程：多线程</li><li>算法：标记-整理算法</li><li>回收位置：回收老生代的数据</li><li>使用原因：关注与吞吐量，有自适应调节机制，可以配合parallel scavenge。</li></ol></li><li><strong>cms收集器</strong>:<ol><li>线程：多线程</li><li>算法：标记-清除算法</li><li>回收位置：回收新生代的数据</li><li>使用原因：用户和清理可以同时进行，降低清理时间。</li></ol></li><li><strong>g1收集器</strong>:<ol><li>线程：多线程</li><li>算法：整体使用标记-整理算法，局部使用复制算法</li><li>回收位置：回收region区域的数据。</li><li>使用原因：可控制的GC时间和内存整理碎片少。</li></ol></li><li><strong>zgc收集器</strong>：<ol><li>设计核心：ZGC的核心原则是将读屏障（load barrier）与彩色指针（colored oops）结合使用</li><li>算法：标记-整理算法</li><li>线程：并发</li><li>回收位置：page区域，三种page</li><li>优势：自己百度，我说不好，我现在也没有理解</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java 集合分类以及细节分析</title>
      <link href="/2018/11/20/collection/%E9%9B%86%E5%90%88%E5%88%86%E6%9E%90%E4%B8%80/"/>
      <url>/2018/11/20/collection/%E9%9B%86%E5%90%88%E5%88%86%E6%9E%90%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>集合如果想真正了解它，就必须自己去看源码，对数据结构有了解，对多线程也应该有了解，集合使用非常频繁的，我们需要知道什么时候使用什么集合，是否需要注意效率，是否需要注意并发下的数据安全。。。<br>首先我们先来看集合的继承关系（图是在网上粘的）</p><p><img src="https://wuzhiwen.oss-cn-beijing.aliyuncs.com/collection.png" alt="集合继承图"></p><center><strong>图：1.0.0</strong></center><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><ol><li><p>Collection:    collection是list和set集合的父接口，它的遍历可以通过iterator接口或者foreach循环遍历。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ol><li><p>List: list子接口是有序集合，所以与Set相比，增加了与索引位置相关的操作</p><h3 id="ArrayLis"><a href="#ArrayLis" class="headerlink" title="ArrayLis"></a>ArrayLis</h3><ul><li><p>1)ArrayLis：<strong>（数组在内存中是连续的，所以查询的话只需要在这连续的内存中移动速度回很快）</strong>ArrayList就是动态的数据，用msdn的说法，就是Array的复杂版本，它提供了动态的添加和删除元素，实现了collection和list接口，可以灵活的设置数据的大小，不过是线程不安全的，建议在单线程中使用。下面我们来分析java源码中是如何实现arraylist的。在源码中Default initial capacity(默认初始容量)是10，这边主要复杂的是add(E e)方法，点进去看下大概的逻辑，如果最小长度小于数组长度则通过grow(minCapacity)方法扩大int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)。其他的方法比较简单可以通过读取源码详细了解。（自己去学习看的才是自己的，这里只是自己的总结，以及我自己需要注意的地方）</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3></li><li><p>2)LinkedList： <strong>（链表的结构可以百度下，它在内存中是不连续的，每个数据会保存下一个数据的地址，需要通过地址进行查找，效率就显得很慢）</strong>LinkedList底层数据结构是链表结构，看源码的话可以知道它实现了List<e>、Deque<e>、Cloneable、java.io.Serializable这几个接口，实现了Deque，所以我们可以把它作为一个双端队列。由于是链表结构，对于增删效率相对会快很多，它不需要进行扩容，但是查询就比数组慢很多，它可以存放任何参数null也是可以的。</e></e></p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3></li><li>3)Vector: 底层是数组，它的操作是线程安全的，线程安全的一般都是牺牲了效率，来看下它的继承和实现 extends AbstractList<e>  implements List<e>, RandomAccess, Cloneable, java.io.Serializable，继承了AbstractList实现了list，所以他是一个队列，支持增删改查等功能。实现了RandomAccess接口，支持随机访问，实现了Cloneable，所以它能被clone。</e></e></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2></li><li><p>Set:    Set集合不允许包含相同的元素，而判断两个对象是否相同则是根据equals方法。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul><li><p>1)HashSet: 看下它的构造会觉得很惊奇，public HashSet() {map = new HashMap&lt;&gt;();}，是不是很惊奇，它用的尽然是HashMap。我们知道Map集合是key,value形式存放数据的，它的key是不允许重复的，如果我们存放对象的话，建议重写equals和hashCode方法。所以如果想了解hashSet就继续看下面的HashMap的解析吧。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3></li><li><p>2)TreeSet:    它的底层实现的是TreeMap,它的数据结构跟TreeMap一样是红黑树。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3></li><li>3)LinkedHashSet:    它extends HashSet<e>，底层也是对HashMap进行一系列排序操作。 </e></li></ul></li></ol></li></ol><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ol start="2"><li><p>Map:    基于散列表实现的一个key-value数据结构，能够实现通过key值快速查找。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol><li><p>HashMap:    继承自AbstractMap抽象类，实现了Map接口。我们现在先对1.7版本jdk对HashMap进行分析。    HashMap有几个比较核心的成员变量</p><ul><li>1.static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4，初始化桶的大小，因为底层是数组，所以这是数据默认的大小。</li><li>2.static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30，桶的最大值。</li><li>3.static final float DEFAULT_LOAD_FACTOR = 0.75f，默认的负载因子。</li><li>4.transient Node&lt;K,V&gt;[] table，真正存放数据的数组。</li><li>5.transient int size，存放数量的大小。</li><li>6.int threshold，桶大小，可在初始化时显示指定。</li><li><p>7.final float loadFactor，负载因子，可在初始化时显示指定。</p><p>重点解释下负载因子：由于给定的hashMap的容量大小都是固定的比如默认初始化<br>public HashMap(int initialCapacity, float loadFactor)。。和public HashMap()。。给定的默认容量为16，负载因子为0.75.Map在使用过程中不断的往里面存放数据，当数量达到了16*0.75=12就需要将当前16的容量进行扩容，而扩容这个过程涉及到rehash、复制数据等操作，所以非常的消耗性能。如果可以预估HashMap的大小可以减少扩容带来的性能损耗，但事实上我们使用的时候都是以方便解决问题而使用。也包括我。</p><p>根据代码可以看到其实真正存放数据的是Entry&lt;K,Y&gt;，但是1.8改成Node&lt;K,V&gt;。<br>Entry是HashMap的一个类部类，从它的成员变量可以很容易的看出:</p></li><li><p>1.key就是写入时的键。</p></li><li>2.Value自然就是值。</li><li>3.我们知道HashMap是一个有数组和链表组成，所以这个Entry&lt;K,V&gt; next的next就是用于实现链表结构。</li><li><p>4.Hash存放的是当前的key的hashcode。</p><p>缺陷：在知晓了基本结构后，我需要仔细分析写入和获取函数：put()和get()方法。当然我这边就不仔细分析了，想看的话请自己看源码。<strong>我主要说下它的缺陷</strong>。他会根据key算出hashcode，然后定位桶的位置，如果桶是链表结构的话，就会对链表遍历，如果key和hashcode都相等，则替换oldValue，那这样就会出现一个问题，如果hashcode一样，但是key不一样的话就会出现在链表进行添加数据，链表就会越来越长，也就会导致查询会慢很多。</p><p>优化：注意下1.8对map的一些优化，主要是查询优化。如果看源码我们会看到一个红黑树的阈值8。还有就是我前面说的entry改成了node。。我们如果看源码可以看到put方法中会判断当前阈值是否超过8，如果超过就会转换成红黑树。如果想了解红黑树的话就请自己百度。但是有些问题并没有解决，HashMap在并发情况下会出现死循环。<br>至于死循环原因可以百度一下，我这边大致说一下，当进行扩容时，它会把桶中的链表    复制后链表进行了反转，在并发的情况下会出现  a-&gt;b-&gt;null 变成 a<->b,具体细节可以通过代码进行研究。</-></p><p>遍历方式：建议使用使用获取EntrySet()进行迭代，效率更高。</p></li></ul><h2 id="ConCurrentHashMap"><a href="#ConCurrentHashMap" class="headerlink" title="ConCurrentHashMap"></a>ConCurrentHashMap</h2></li><li><p>ConCurrentHashMap：线程安全的map集合。（一个大牛的总结，但是找不到文章来源）</p><ul><li><p><strong>1.7版本</strong>：在1.7中它的组成是由Segment数组和HashEntry组成，和hashMap一样，任然是由数组加链表。Segment是ConcurrentHashMap的一个内部类，跟HashMap非常相似，唯一的区别就是其中的核心数据都是被volatile修饰，保证了获取时的可见性。<br>原理上来说：ConCurrentHashMap采用了分段锁技术，其中Segment继承ReentrantLock。不会像HashTable那样不管是put还是get都需要做同步处理，理论上ConCurrentHashMap支持CurrentLevel（segment数组数量）的线程并发。每当一个线程占用锁访问一个segment时，不会影响其他的segment。详细了解put方法，虽然我们用volatile修饰value但是不能保证原子性，所以put操作我们需要加锁处理。首先我们会尝试获取锁，如果没有获取则说明存在其他线程竞争，则利用scanAndLockForPut()自旋获取锁，如果重试次数达到最大，则改为阻塞锁获取，保证能获取成功。</p></li><li><p><strong>1.8版本</strong>：虽然1.7对并发已经做了处理但是还是存在一些缺点，查询效率慢。1.8中采用红黑树确保查询效率，同时取消了ReentrantLock改为synchronized，这样可以看出在新版本的jdk对synchronized优化很到位。CAS+synchronized保证并发安全。</p></li></ul><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2></li><li><p>LinkedHashMap：它是hashMap的子类，所以它拥有hashMap所有的功能，而且它还增加了一项功能就是有    序。HashMap和双向链表合二为一即是LinkedHashMap，因此更准确地说，它是一个将所有Entry节点链入一    个双向链表双向链表的HashMap。。。。<br> 实在写不下去了。。。。自己百度去吧，不过需要注意仔细了解下<a href="http://blog.jobbole.com/111680/#article-comment" target="_blank" rel="noopener">红黑树数据结构</a>。</p><p> 还要给新手一个忠告，如果想学的深，就自己去看源码，不要总是看别人的总结。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 集合 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>分布式锁的实现方案</title>
      <link href="/2018/11/20/distuted/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
      <url>/2018/11/20/distuted/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>什么时候需要分布式锁，我们来举一个很典型的例子，开发人员通过接口进行转账，我们有时候会多次点击按钮，发送转账请求，请求多次，每次系统都进行处理的话，银行估计早已经被我们这些开发人员搞破产了。<br><br>个人认为不是只有分布式系统才用锁的，只是分布式系统存在这种情况比较多，处理难度比较大，所以才有这样的概念。</p><p>锁的含义很简单，就是一个标识，我有这个标识我就可以运行方法，没有这个标识就只能等待。</p><p>通过百度后，找到了三种方案，</p><ol><li>基于数据库表方式实现</li><li>基于缓存方式实现<ul><li><a href="/2018/11/20/distuted/redis分布式锁">单台redis分布式锁实现</a></li><li><a href="/2018/11/20/distuted/redis分布式锁二">redis集群分布式锁实现</a></li></ul></li><li><a href="/2018/11/20/distuted/zk分布式锁的原理和实现">基于zookeeper方式实现</a></li></ol><p>这里只介绍具体的实现方式，以及代码提供，因为我也是百度别人的，自己实践下。<br>参考的博客</p><p><a href="https://www.cnblogs.com/austinspark-jessylu/p/8043726.html" title="分布式锁三种实现方案" target="_blank" rel="noopener">分布式锁三种实现方案</a><br><a href="https://www.cnblogs.com/linjiqin/p/8003838.html" title="redis分布式锁" target="_blank" rel="noopener">redis分布式锁</a><br><a href="https://www.cnblogs.com/0201zcr/p/5942748.html" title="redis分布式详解" target="_blank" rel="noopener">redis分布式详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>二分法的一些bug和实现</title>
      <link href="/2018/11/20/math/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9Bbug%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/20/math/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9Bbug%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>今天看到一个博客，说 java.util.Arrays.binarySearch（）曾经写错了，将近十年没有被发现。我现在将代码实现下，大家看看有什么问题。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">       int[] data = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;</span><br><span class="line">       int key = 8;</span><br><span class="line"></span><br><span class="line">       int hight = data.length - 1;</span><br><span class="line">       int low = 0;</span><br><span class="line">       while (low &lt;= hight) &#123;</span><br><span class="line">           int mid = (hight + low) / 2;</span><br><span class="line">           if (data[mid] &gt; key)</span><br><span class="line">               low = mid++;</span><br><span class="line">           else if (data[mid] &lt; key)</span><br><span class="line">               hight = mid--;</span><br><span class="line">           else break;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println((hight + low) / 2 + 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre><p>先自己写了一个二分查询，结果死循环了，断点跟了下 0– 一直为0,很尴尬。<br>想了下 很尴尬啊–是先赋值在减的，习惯用–都忘了好多细节，所以上面的代码错完了。<br>不清楚的可以运行下下面的代码</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int k = 0;</span><br><span class="line">       System.out.println(k--);</span><br><span class="line">       System.out.println(k);</span><br></pre></td></tr></table></figure></code></pre><p>终于把二分写好了</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int[] data = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;</span><br><span class="line">       int key = 8;</span><br><span class="line"></span><br><span class="line">       int hight = data.length - 1;</span><br><span class="line">       int low = 0;</span><br><span class="line">       while (low &lt;= hight) &#123;</span><br><span class="line">           int mid = (hight + low) / 2;</span><br><span class="line">           if (data[mid] &lt; key)</span><br><span class="line">               low = ++mid;</span><br><span class="line">           else if (data[mid] &gt; key)</span><br><span class="line">               hight = --mid;</span><br><span class="line">           else break;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println((hight + low) / 2+1);</span><br></pre></td></tr></table></figure></code></pre><p>这样的代码就对了吗？<br>我觉得我辛苦写出来的代码应该没有问题了，想了好久也没有想出来，只能看别人的答案了 <br><br>int mid = (hight + low) / 2;会出现溢出。我瞬间知道了int 长度是有限（2147483647）2的31次方，只能说自己的基础知识还是不扎实，不由得想起了上学时的自己，上课玩手机真的是浪费自己的时间啊。<br>那是如何解决的呢？ 位移运算如果大家知道的话就很简单了int mid = (hight + low) &gt;&gt;&gt; 1。其实二分法我很久没写了，我想了好长时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>zk分布式锁的原理和实现</title>
      <link href="/2018/11/20/distuted/zk%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/20/distuted/zk%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qiangcuo6087/article/details/79067136" target="_blank" rel="noopener">参考博客1注重原理分析</a><br><a href="https://www.cnblogs.com/liuyang0/p/6800538.html" target="_blank" rel="noopener">参考博客2代码实现</a><br>参考博客写的很好，我现在肯定没有他的水平高，不过我也需要练习，顺便记录下来，所以希望大家见谅，我会尽量优化和补全他们的代码。</p><p>通过对redis分布式锁的实现，我已经可以很清楚的知道分布式锁的实现需要满足以下几点：</p><ol><li>必须是可以锁住，不会出现并发。</li><li>不会出现死锁。</li><li><p>不会丢失锁<br>其他的要求都是细节上的打磨。我们围绕着这几个点来说明下为什么zk可以实现分布式锁。</p></li><li><p>zookeeper需要以集群形态来部署来保证它的高可用。</p></li><li>zookeeper可以跟客户端创建临时的节点，<strong>直到会话结束或者超时或者客户端宕机(心跳检查失败)，节点会被删除。</strong></li><li>节点的创建可以使有序的，在一个父节点下创建子节点，只要指明是有序的，那么zk创建子节点时会添加节点序号。</li><li>事件的监听，当我们读取节点时可以对节点设置监听，而且<strong>读取节点和设置监听是原子性的操作</strong>。<br>以上几点是zk符合作为实现分布式锁的原因。</li></ol><p>zookeeper能够实现锁的原理流程<br>假设zookeeper中根节点是/lock</p><ol><li>第一个客户端连接zookeeper并创建有序节点/lock/node-0000000,第二个客户端连接zookeeper创建有序节点/lock/node-0000001，以此类推，</li><li>客户端获取节点列表，判断自己的节点是否是最小的，如果是最小的，则获取锁，如果不是最小的则设置监听，直到节点变更后重复此步骤。</li><li>客户端获取锁后执行业务代码</li><li>然后删除节点</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>1.设置异常</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.exception;</span><br><span class="line"></span><br><span class="line">public class LockException extends RuntimeException &#123;</span><br><span class="line">        private static final long serialVersionUID = 1L;</span><br><span class="line">        public LockException(String e)&#123;</span><br><span class="line">            super(e);</span><br><span class="line">        &#125;</span><br><span class="line">        public LockException(Exception e)&#123;</span><br><span class="line">            super(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><p>2.实现DistributedLock </p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.util;</span><br><span class="line">import com.zhiwen.exception.LockException;</span><br><span class="line">import org.apache.zookeeper.CreateMode;</span><br><span class="line">import org.apache.zookeeper.KeeperException;</span><br><span class="line">import org.apache.zookeeper.WatchedEvent;</span><br><span class="line">import org.apache.zookeeper.Watcher;</span><br><span class="line">import org.apache.zookeeper.ZooDefs;</span><br><span class="line">import org.apache.zookeeper.ZooKeeper;</span><br><span class="line">import org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Auther: wuzhiwen</span><br><span class="line"> * @Date: 2018/11/11 15:47</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">public class DistributedLock implements Lock, Watcher &#123;</span><br><span class="line">    //zookeeper连接</span><br><span class="line">    private ZooKeeper zooKeeper = null;</span><br><span class="line"></span><br><span class="line">    //会话时间</span><br><span class="line">    private int sessionTimeout = 30000;</span><br><span class="line"></span><br><span class="line">    //根节点</span><br><span class="line">    private String rootLock = &quot;/rootlock&quot;;</span><br><span class="line"></span><br><span class="line">    //计数器</span><br><span class="line">    private CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    //异常集合</span><br><span class="line">    private List&lt;Exception&gt; exceptionList = new ArrayList&lt;Exception&gt;();</span><br><span class="line"></span><br><span class="line">    //等待前一个锁</span><br><span class="line">    private String WAIT_LOCK;</span><br><span class="line"></span><br><span class="line">    //竞争的资源</span><br><span class="line">    private String lockName;</span><br><span class="line"></span><br><span class="line">    //当前锁</span><br><span class="line">    // 当前锁</span><br><span class="line">    private String CURRENT_LOCK;</span><br><span class="line"></span><br><span class="line">    public DistributedLock(String config, String lockName) &#123;</span><br><span class="line">            this.lockName = lockName;</span><br><span class="line">        try &#123;</span><br><span class="line">            zooKeeper = new ZooKeeper(config, sessionTimeout, this);</span><br><span class="line">            //判断根节点是否存在, false则不是有this.watchManager.defaultWatcher 默认的Watcher</span><br><span class="line">            Stat stat = zooKeeper.exists(rootLock, false);</span><br><span class="line">            if (stat == null) &#123;</span><br><span class="line">                //path：创建节点路径，需保证父节点已存在 ,data：节点数据 acl:权限列表, createMode:节点类型</span><br><span class="line">                /*</span><br><span class="line">                 *  acl:权限列表</span><br><span class="line">                 *      OPEN_ACL_UNSAFE：完全开放</span><br><span class="line">                 *      CREATOR_ALL_ACL：创建该znode的连接拥有所有权限</span><br><span class="line">                 *      READ_ACL_UNSAFE：所有的客户端都可读</span><br><span class="line">                 *</span><br><span class="line">                 *   createMode:节点类型</span><br><span class="line">                 *      PERSISTENT：持久化节点</span><br><span class="line">                 *      PERSISTENT_SEQUENTIAL：持久化有序节点</span><br><span class="line">                 *      EPHEMERAL：临时节点（连接断开自动删除）</span><br><span class="line">                 *      EPHEMERAL_SEQUENTIAL：临时有序节点（连接断开自动删除）</span><br><span class="line">                 *</span><br><span class="line">                 */</span><br><span class="line">                zooKeeper.create(rootLock, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        //对异常进行判断</span><br><span class="line">        if (exceptionList.size() &gt; 0) &#123;</span><br><span class="line">            throw new LockException(exceptionList.get(0));</span><br><span class="line">        &#125;</span><br><span class="line">        //获取锁</span><br><span class="line">        if (this.tryLock()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; &quot; + lockName + &quot;获得了锁&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            waitLocak(WAIT_LOCK, sessionTimeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置监听</span><br><span class="line">    private boolean waitLocak(String wait_lock, long sessionTimeout) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Stat stat = zooKeeper.exists(rootLock + &quot;/&quot; + wait_lock, true);</span><br><span class="line">            if (stat != null) &#123;</span><br><span class="line">                //创建计数</span><br><span class="line">                this.countDownLatch = new CountDownLatch(1);</span><br><span class="line">                // 计数等待，若等到前一个节点消失，则precess中进行countDown，停止等待，获取锁</span><br><span class="line">                this.countDownLatch.await(sessionTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                this.countDownLatch = null;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        this.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //设置子节点命名规则，便于后别切割分别和排序</span><br><span class="line">            String lockSplit = &quot;_lock_&quot;;</span><br><span class="line">            String sonName = rootLock + &quot;/&quot; + lockName + lockSplit;</span><br><span class="line">            //创建临时子节点</span><br><span class="line">            CURRENT_LOCK = zooKeeper.create(sonName, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            //获取所有子节点列表</span><br><span class="line">            List&lt;String&gt; children = zooKeeper.getChildren(rootLock, false);</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; sonList = new ArrayList&lt;&gt;();</span><br><span class="line">            //判断是否是最小节点</span><br><span class="line">            for (String child : children) &#123;</span><br><span class="line">                //将所有节点根据命名规则切割</span><br><span class="line">                String[] split = child.split(lockSplit);</span><br><span class="line">                //只将该资源下的节点保存</span><br><span class="line">                if (split[0].equals(lockName)) &#123;</span><br><span class="line">                    sonList.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">                //排序</span><br><span class="line">                Collections.sort(sonList);</span><br><span class="line">                //判断最小</span><br><span class="line">                if (CURRENT_LOCK.equals(rootLock + &quot;/&quot; + sonList.get(0))) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                //这样的写法相对的是遍历查询，效率不是很高，</span><br><span class="line">                //如果不是 则找到自己前面的节点</span><br><span class="line">                for (int i = 0; i &lt; sonList.size(); i++) &#123;</span><br><span class="line">                    if (CURRENT_LOCK.equals(rootLock + &quot;/&quot; + sonList.get(i))) &#123;</span><br><span class="line">                        //对前一个小的节点进行定位</span><br><span class="line">                        WAIT_LOCK = sonList.get(--i);</span><br><span class="line">                        //在这里设置监听会好点 我觉得</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 若不是最小节点，则找到自己的前一个节点</span><br><span class="line">                // 因为我们已经进行了排序，所以使用集合自带Collections.binarySearch()的方法，二分查找效率会快点。</span><br><span class="line">//                String prevNode = CURRENT_LOCK.substring(CURRENT_LOCK.lastIndexOf(&quot;/&quot;) + 1);</span><br><span class="line">//                WAIT_LOCK = sonList.get(Collections.binarySearch(sonList, prevNode) - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        if (this.tryLock()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return waitLocak(WAIT_LOCK, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;删除锁&quot;);</span><br><span class="line">            zooKeeper.delete(CURRENT_LOCK, -1);</span><br><span class="line">            CURRENT_LOCK = null;</span><br><span class="line">            zooKeeper.close();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 节点监视器</span><br><span class="line">     *</span><br><span class="line">     * @param watchedEvent</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void process(WatchedEvent watchedEvent) &#123;</span><br><span class="line">        if (countDownLatch != null) &#123;</span><br><span class="line">            this.countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>2.测试代码 </p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.controller;</span><br><span class="line"></span><br><span class="line">import com.zhiwen.util.DistributedLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Auther: wuzhiwen</span><br><span class="line"> * @Date: 2018/11/12 10:46</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">public class ZkDistributed &#123;</span><br><span class="line"></span><br><span class="line">    static int n = 500;</span><br><span class="line"></span><br><span class="line">    public static void secskill() &#123;</span><br><span class="line">        System.out.println(--n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                DistributedLock lock = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock = new DistributedLock(&quot;192.168.91.129:2181&quot;, &quot;test1&quot;);</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    secskill();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;正在运行&quot;);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (lock != null) &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread t = new Thread(runnable);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>启动后会报错，日志jar冲突<br><br>解决方法：<br></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.4.8&lt;/version&gt;</span><br><span class="line">          &lt;exclusions&gt;</span><br><span class="line">              &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/exclusion&gt;</span><br><span class="line">              &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt;</span><br><span class="line">          &lt;/exclusions&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></code></pre><p>我在写DistributedLock类时，根据原理流程参考了博客后，自己书写的，有些代码是粘的，但是都是经过测试，可以放心使用。<br><br>测试代码<a href="https://gitee.com/ZuiJi/distributed.git" target="_blank" rel="noopener">https://gitee.com/ZuiJi/distributed.git</a></p><p>这样的代码其实缺陷还是很多的，由于没有很好地环境进行测试，有时候我自己很难想出哪里有什么问题，我一直认为自己写的代码是完美的！！！。为了可以提高代码的稳定性、可靠性、有效性，我们来看下别人的代码（别人家的孩子总是好的！！！！）</p><p>导入依赖，看下别人的实现方式好在哪里</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">&lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></code></pre><p>我们来看下写好的测试方法</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.controller;</span><br><span class="line"></span><br><span class="line">import com.zhiwen.util.DistributedLock;</span><br><span class="line">import org.apache.curator.RetryPolicy;</span><br><span class="line">import org.apache.curator.framework.CuratorFramework;</span><br><span class="line">import org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line">import org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line">import org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Auther: wuzhiwen</span><br><span class="line"> * @Date: 2018/11/12 12:29</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">public class CuratorDistributed &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //创建zookeeper的客户端</span><br><span class="line">                    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">//                    CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.91.129:2181,192.168.91.129:2182,192.168.91.129:2183&quot;, retryPolicy);</span><br><span class="line">                    CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;192.168.91.129:2181&quot;, retryPolicy);</span><br><span class="line">                    client.start();</span><br><span class="line">                    //创建分布式锁, 锁空间的根节点路径为/curator/lock</span><br><span class="line">                    InterProcessMutex mutex = new InterProcessMutex(client, &quot;/rootCurator/lock&quot;);</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    //获得了锁, 进行业务流程</span><br><span class="line">                    System.out.println(&quot;业务运行成功&quot;);</span><br><span class="line">                    //完成业务流程, 释放锁</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    //关闭客户端</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread t = new Thread(runnable);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>使用别人的代码感觉就是很简单，好了我们来看下curator加锁和解锁的方法优秀之处。<br>加锁mutex.acquire()方法实现的，来看下源码：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">点击去后可以看到方法</span><br><span class="line"></span><br><span class="line">public void acquire() throws Exception &#123;</span><br><span class="line">        if (!this.internalLock(-1L, (TimeUnit)null)) &#123;</span><br><span class="line">//如果失去连接则会抛出异常</span><br><span class="line">            throw new IOException(&quot;Lost connection while trying to acquire lock: &quot; + this.basePath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">接着点入this.internalLock(-1L, (TimeUnit)null)方法</span><br><span class="line"></span><br><span class="line">private boolean internalLock(long time, TimeUnit unit) throws Exception &#123;</span><br><span class="line">//获取当前线程</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">//获取当前锁</span><br><span class="line">        InterProcessMutex.LockData lockData = (InterProcessMutex.LockData)this.threadData.get(currentThread);</span><br><span class="line">//如果不为null,则说明获取锁，返回true</span><br><span class="line">        if (lockData != null) &#123;</span><br><span class="line">            lockData.lockCount.incrementAndGet();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">//获取当前锁节点，在这个方法中它会一直等待，知道加锁成功</span><br><span class="line">            String lockPath = this.internals.attemptLock(time, unit, this.getLockNodeBytes());</span><br><span class="line">            if (lockPath != null) &#123;</span><br><span class="line">//成功后记录锁的信息，</span><br><span class="line">                InterProcessMutex.LockData newLockData = new InterProcessMutex.LockData(currentThread, lockPath, null);</span><br><span class="line">                this.threadData.put(currentThread, newLockData);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">//没有获取锁，失败处理，在上一个方法会抛出通信失败异常</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">this.internals.attemptLock(time, unit, this.getLockNodeBytes())方法</span><br><span class="line"></span><br><span class="line">String attemptLock(long time, TimeUnit unit, byte[] lockNodeBytes) throws Exception &#123;</span><br><span class="line">        long startMillis = System.currentTimeMillis();</span><br><span class="line">        Long millisToWait = unit != null ? unit.toMillis(time) : null;</span><br><span class="line">        byte[] localLockNodeBytes = this.revocable.get() != null ? new byte[0] : lockNodeBytes;</span><br><span class="line">        int retryCount = 0;</span><br><span class="line">        String ourPath = null;</span><br><span class="line">        boolean hasTheLock = false;</span><br><span class="line">        boolean isDone = false;</span><br><span class="line">//以上是初始化参数</span><br><span class="line"></span><br><span class="line">//刚开始我看着到这也是不懂，这样是干嘛呢？</span><br><span class="line">        while(!isDone) &#123;</span><br><span class="line">            isDone = true;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">//在锁空间下创建临时且有序的子节点</span><br><span class="line">                ourPath = this.driver.createsTheLock(this.client, this.path, localLockNodeBytes);</span><br><span class="line">//判断获取锁是否是最小的，不是最小则一直监听比它小一个的节点</span><br><span class="line">                hasTheLock = this.internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">            &#125; catch (NoNodeException var14) &#123;</span><br><span class="line">//NoNodeException是只有会话结束时才会抛出的异常，所以会进行重试，如果是会话结束 才throw var14;</span><br><span class="line">                if (!this.client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper())) &#123;</span><br><span class="line">                    throw var14;</span><br><span class="line">                &#125;</span><br><span class="line">//现在知道了，这个是作为判断是否出现异常，异常了还要继续进行</span><br><span class="line">                isDone = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return hasTheLock ? ourPath : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><p>internalLockLoop(startMillis, millisToWait, ourPath)核心方法，我前面写的tryLock()效果跟他差不多，不过很明显在严谨上是不如它的。尴尬</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private boolean internalLockLoop(long startMillis, Long millisToWait, String ourPath) throws Exception &#123;</span><br><span class="line">//两个标记</span><br><span class="line">       boolean haveTheLock = false;</span><br><span class="line">       boolean doDelete = false;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           if (this.revocable.get() != null) &#123;</span><br><span class="line">               ((BackgroundPathable)this.client.getData().usingWatcher(this.revocableWatcher)).forPath(ourPath);</span><br><span class="line">           &#125;</span><br><span class="line">//我们后面再来看这个比较的意义</span><br><span class="line">           while(this.client.getState() == CuratorFrameworkState.STARTED &amp;&amp; !haveTheLock) &#123;</span><br><span class="line">//获取所有的字节点</span><br><span class="line">               List&lt;String&gt; children = this.getSortedChildren();</span><br><span class="line">//如果大家跟着前面代码看完了则很简单这个是获取节点名</span><br><span class="line">               String sequenceNodeName = ourPath.substring(this.basePath.length() + 1);</span><br><span class="line">//判断是否是最小节点</span><br><span class="line">               PredicateResults predicateResults = this.driver.getsTheLock(this.client, children, sequenceNodeName, this.maxLeases);</span><br><span class="line">//如果是最小节点则返回true</span><br><span class="line">               if (predicateResults.getsTheLock()) &#123;</span><br><span class="line">                   haveTheLock = true;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">//下面的方法大家肯定知道了 就是设置监听了啊，先获取比自己小一个的节点，然后监听。</span><br><span class="line"></span><br><span class="line">//获取比自己小一个的节点</span><br><span class="line">                   String previousSequencePath = this.basePath + &quot;/&quot; + predicateResults.getPathToWatch();</span><br><span class="line">//加锁保证不会并发，但是我也不知道并发会发生什么？？</span><br><span class="line">//别人的解释：这里使用对象监视器做线程同步，当获取不到锁时监听前一个子节点删除消息并且进行wait()，当前一个子节点删除（也就是锁释放）时，回调会通过</span><br><span class="line">//notifyAll唤醒此线程，此线程继续自旋判断是否获得锁.但是这样会有一个消耗notifyAll,会唤醒所有线程，消耗会很大啊。</span><br><span class="line">                   synchronized(this) &#123;</span><br><span class="line">                       try &#123;</span><br><span class="line">//这里使用getData(),为什么不用checkExists?我们知道如果使用checkExists它是查询和设置监听一起完成的，它的操作具有原子性的。</span><br><span class="line">//如果前一个节点已经删除了，则监听会一直监听，这是一种资源泄露（看别人是这样说的）。</span><br><span class="line">//使用getData()，如果监听的节点被删除了,则会抛出异常，回到上面 isDone=false 则只需自旋解锁一次就可以了。</span><br><span class="line">//看到这里，那我自己也行修改下前面自己定义的zookeeper.exite()，方法</span><br><span class="line">                           ((BackgroundPathable)this.client.getData().usingWatcher(this.watcher)).forPath(previousSequencePath);</span><br><span class="line">//最小等待时间不为null,则继续等待</span><br><span class="line">                           if (millisToWait == null) &#123;</span><br><span class="line">                               this.wait();</span><br><span class="line">                           &#125; else &#123;</span><br><span class="line">//设置等待时间</span><br><span class="line">                               millisToWait = millisToWait - (System.currentTimeMillis() - startMillis);</span><br><span class="line">                               startMillis = System.currentTimeMillis();</span><br><span class="line">                               if (millisToWait &gt; 0L) &#123;</span><br><span class="line">                                   this.wait(millisToWait);</span><br><span class="line">                               &#125; else &#123;</span><br><span class="line">//无等待时间，则在finally删除该节点</span><br><span class="line">                                   doDelete = true;</span><br><span class="line">                                   break;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; catch (NoNodeException var19) &#123;</span><br><span class="line">                           ;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception var21) &#123;</span><br><span class="line">           ThreadUtils.checkInterrupted(var21);</span><br><span class="line">           doDelete = true;</span><br><span class="line">           throw var21;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (doDelete) &#123;</span><br><span class="line">               this.deleteOurPath(ourPath);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       return haveTheLock;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre><p>mutex.release();这个就相当于我写的unlock()大家自己去看吧。<br>看完别人写的源码后，我自己又去优化了下代码，现在还没有跑起来，估计是今天</p>]]></content>
      
      
      <categories>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>springCloud学习记录</title>
      <link href="/2018/11/20/springCloud/springCloud%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/11/20/springCloud/springCloud%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>学习书籍<strong>springCloud微服务实战</strong></p>]]></content>
      
      
      <categories>
          
          <category> springCloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>redis一些知识</title>
      <link href="/2018/11/20/redis/redis%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/11/20/redis/redis%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>学习的博客地址<a href="http://blog.jobbole.com/113789/" target="_blank" rel="noopener">http://blog.jobbole.com/113789/</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>redis集群分布式锁实现</title>
      <link href="/2018/11/20/distuted/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BA%8C/"/>
      <url>/2018/11/20/distuted/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zhuyu19911016520/article/details/80418161" target="_blank" rel="noopener">参考的博客1</a><br><br><a href="https://blog.csdn.net/qsssyyw/article/details/81562868" target="_blank" rel="noopener">参考的博客1</a><br><br>当redis 集群后，对分布式锁需要比较复杂的开发，不过很幸运<a href="https://www.cnblogs.com/mcbye/archive/2017/08/18/Jedis-VS-Redisson.html" target="_blank" rel="noopener">redission</a>提供了很好的方法。至于原理我暂时还没有搞定，这是我看的一个博客解释的还可以吧我觉得还可以<a href="https://www.cnblogs.com/diegodu/p/8185480.html" target="_blank" rel="noopener">https://www.cnblogs.com/diegodu/p/8185480.html</a>，以后再说吧。先学怎么使用，再来考虑原理是我学习的方式。<br><a href="https://blog.csdn.net/csujiangyu/article/details/51005342" target="_blank" rel="noopener">redission</a>支持redis集群、哨兵等多种模式。下面我将会一一展示。不过我们需要自己先搭建一个redis集群，我个人用<a href="https://blog.csdn.net/qq_22211217/article/details/80436996" target="_blank" rel="noopener">docker</a>搭建的，这是一个比较简单的搭建方式，如果有兴趣的可以去尝试，也有自己做镜像的，有的公司为了安全保密什么的，只要求运维自己做镜像。我的一个同事对<a href="http://fyjblogs.pmty.xyz/" target="_blank" rel="noopener">docker</a>有不小的研究，大家有兴趣可以将他的博客细致的看下，他写的是一个系统的学习docker路径以及教程，而且写的很是细致。</p><h2 id="代码实现-基于springboot写的"><a href="#代码实现-基于springboot写的" class="headerlink" title="代码实现  基于springboot写的"></a>代码实现  基于springboot写的</h2><p>1.配置RedissonClient</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.config;</span><br><span class="line"></span><br><span class="line">import org.redisson.Redisson;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.redisson.config.Config;</span><br><span class="line">import org.redisson.config.MasterSlaveServersConfig;</span><br><span class="line">import org.redisson.config.SentinelServersConfig;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Auther: wuzhiwen</span><br><span class="line"> * @Date: 2018/11/9 15:48</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RedissonManager &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.redis.clusters&#125;&quot;)</span><br><span class="line">    private  String cluster;</span><br><span class="line">    @Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient getRedisson()&#123;</span><br><span class="line">//在application.properties文件加上 ip：port 以逗号分隔</span><br><span class="line">        String[] nodes = cluster.split(&quot;,&quot;);</span><br><span class="line">        //redisson版本是3.5，集群的ip前面要加上“redis://”，不然会报错，3.2版本可不加</span><br><span class="line">        for(int i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">            nodes[i] = &quot;redis://&quot;+nodes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        RedissonClient redisson = null;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        //下面是各种模式的代码实现</span><br><span class="line">//        config.useClusterServers() //这是用的集群server</span><br><span class="line">//                .setScanInterval(2000) //设置集群状态扫描时间</span><br><span class="line">//                .addNodeAddress(nodes)</span><br><span class="line">//                .setPassword(password);</span><br><span class="line">//        redisson = Redisson.create(config);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        SentinelServersConfig mymaster = config.useSentinelServers().//哨兵模式</span><br><span class="line">//                setMasterName(&quot;mymaster&quot;);</span><br><span class="line">//        for (String node : nodes) &#123;</span><br><span class="line">//            mymaster.addSentinelAddress(node);</span><br><span class="line">//        &#125;</span><br><span class="line">//        redisson = Redisson.create(config);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        MasterSlaveServersConfig masterSlaveServersConfig = config.useMasterSlaveServers() //主从复制的模式</span><br><span class="line">//                .setMasterAddress(nodes[0]);</span><br><span class="line">//        for (int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">//            masterSlaveServersConfig.addSlaveAddress(nodes[i]);</span><br><span class="line">//        &#125;</span><br><span class="line">//        redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        config.useSingleServer().setAddress(nodes[0]);//单机模式</span><br><span class="line">        redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //可通过打印redisson.getConfig().toJSON().toString()来检测是否配置成功</span><br><span class="line">        return redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>2.定义DistributedLocker接口</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.distributed;</span><br><span class="line"></span><br><span class="line">import org.redisson.api.RLock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line">public interface DistributedLocker &#123;</span><br><span class="line"> </span><br><span class="line">    RLock lock(String lockKey);</span><br><span class="line"> </span><br><span class="line">    RLock lock(String lockKey, long timeout);</span><br><span class="line"> </span><br><span class="line">    RLock lock(String lockKey, TimeUnit unit, long timeout);</span><br><span class="line"> </span><br><span class="line">    boolean tryLock(String lockKey, TimeUnit unit, long waitTime, long leaseTime);</span><br><span class="line"> </span><br><span class="line">    void unlock(String lockKey);</span><br><span class="line"> </span><br><span class="line">    void unlock(RLock lock);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>3.实现DistributedLocker接口</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.distributed.impl;</span><br><span class="line"></span><br><span class="line">import com.zhiwen.distributed.DistributedLocker;</span><br><span class="line">import org.redisson.api.RLock;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class RedissonDistributedLocker implements DistributedLocker &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedissonClient redissonClient;  //RedissonClient已经由配置类生成，这里自动装配即可</span><br><span class="line"></span><br><span class="line">    //lock(), 拿不到lock就不罢休，不然线程就一直block</span><br><span class="line">    @Override</span><br><span class="line">    public RLock lock(String lockKey) &#123;</span><br><span class="line">        RLock lock = redissonClient.getLock(lockKey);</span><br><span class="line">        lock.lock();</span><br><span class="line">        return lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //leaseTime为加锁时间，单位为秒</span><br><span class="line">    @Override</span><br><span class="line">    public RLock lock(String lockKey, long leaseTime) &#123;</span><br><span class="line">        RLock lock = redissonClient.getLock(lockKey);</span><br><span class="line">        lock.lock(leaseTime, TimeUnit.SECONDS);</span><br><span class="line">        return lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //timeout为加锁时间，时间单位由unit确定</span><br><span class="line">    @Override</span><br><span class="line">    public RLock lock(String lockKey, TimeUnit unit, long timeout) &#123;</span><br><span class="line">        RLock lock = redissonClient.getLock(lockKey);</span><br><span class="line">        lock.lock(timeout, unit);</span><br><span class="line">        return lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //tryLock()，马上返回，拿到lock就返回true，不然返回false。</span><br><span class="line">    //带时间限制的tryLock()，拿不到lock，就等一段时间，超时返回false.</span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(String lockKey, TimeUnit unit, long waitTime, long leaseTime) &#123;</span><br><span class="line">        RLock lock = redissonClient.getLock(lockKey);</span><br><span class="line">        try &#123;</span><br><span class="line">            return lock.tryLock(waitTime, leaseTime, unit);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(String lockKey) &#123;</span><br><span class="line">        RLock lock = redissonClient.getLock(lockKey);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock(RLock lock) &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>3.测试lock</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import com.zhiwen.RedissionApplication;</span><br><span class="line">import com.zhiwen.distributed.DistributedLocker;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line">import org.springframework.test.context.web.WebAppConfiguration;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Auther: wuzhiwen</span><br><span class="line"> * @Date: 2018/11/9 16:57</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@SpringBootTest(classes = RedissionApplication.class)</span><br><span class="line">public class DistrubutedLockTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DistributedLocker distributedLocker;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void redissonTest() &#123;</span><br><span class="line">        String key = &quot;redisson_key&quot;;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.err.println(&quot;=============线程开启============&quot;+Thread.currentThread().getName());</span><br><span class="line">/*distributedLocker.lock(key,10L); //直接加锁，获取不到锁则一直等待获取锁</span><br><span class="line"> Thread.sleep(100); //获得锁之后可以进行相应的处理</span><br><span class="line"> System.err.println(&quot;======获得锁后进行相应的操作======&quot;+Thread.currentThread().getName());</span><br><span class="line"> distributedLocker.unlock(key);  //解锁</span><br><span class="line"> System.err.println(&quot;=============================&quot;+Thread.currentThread().getName());*/</span><br><span class="line">                        boolean isGetLock =  distributedLocker.tryLock(key, TimeUnit.SECONDS,5L,10L); //尝试获取锁，等待5秒，自己获得锁后一直不解锁则10秒后自动解锁</span><br><span class="line">                        if(isGetLock)&#123;</span><br><span class="line">                            Thread.sleep(100); //获得锁之后可以进行相应的处理</span><br><span class="line">                            System.err.println(&quot;======获得锁后进行相应的操作======&quot;+Thread.currentThread().getName());</span><br><span class="line">                            //distributedLocker.unlock(key);</span><br><span class="line">                            System.err.println(&quot;=============================&quot;+Thread.currentThread().getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>如果大家跟着我这样测试的话，结果是 redission shutdown，无法测试成功，所以换了一种方式测试</p><p>3.测试lock2</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.zhiwen.controller;</span><br><span class="line"></span><br><span class="line">import com.zhiwen.util.RedissLockUtil;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Auther: wuzhiwen</span><br><span class="line"> * @Date: 2018/11/11 13:26</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class RedissionController &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">    private DistributedLocker distributedLocker;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/demo&quot;)</span><br><span class="line">    public String demo()&#123;</span><br><span class="line">        String key = &quot;redisson_key&quot;;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.err.println(&quot;=============线程开启============&quot;+Thread.currentThread().getName());</span><br><span class="line">//                        distributedLocker.lock(key,10); //直接加锁，获取不到锁则一直等待获取锁</span><br><span class="line">//                        Thread.sleep(100); //获得锁之后可以进行相应的处理</span><br><span class="line">//                        System.err.println(&quot;======获得锁后进行相应的操作======&quot;+Thread.currentThread().getName());</span><br><span class="line">//                        distributedLocker.unlock(key);  //解锁</span><br><span class="line">//                        System.err.println(&quot;=============================&quot;+Thread.currentThread().getName());</span><br><span class="line">boolean isGetLock =  distributedLocker.tryLock(key, TimeUnit.SECONDS,5,10); //尝试获取锁，等待5秒，自己获得锁后一直不解锁则10秒后自动解锁</span><br><span class="line">                        if(isGetLock)&#123;</span><br><span class="line">                            Thread.sleep(100); //获得锁之后可以进行相应的处理</span><br><span class="line">                            System.err.println(&quot;======获得锁后进行相应的操作======&quot;+Thread.currentThread().getName());</span><br><span class="line">                            distributedLocker.unlock(key);</span><br><span class="line">                            System.err.println(&quot;=============================&quot;+Thread.currentThread().getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>这样测试可以看到锁的执行过程。测试代码<a href="https://gitee.com/ZuiJi/distributed.git" target="_blank" rel="noopener">https://gitee.com/ZuiJi/distributed.git</a>测试代码是经过优化的，剩下的是根据项目具体要求进行书写了。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>redis实现分布式锁实现代码以及原理分析</title>
      <link href="/2018/11/20/distuted/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2018/11/20/distuted/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>不是只有redis,才可以做分布式锁，只是redis分布式锁博客比较多，好百度而已。</p><h2 id="为什么redis可以实现分布式锁"><a href="#为什么redis可以实现分布式锁" class="headerlink" title="为什么redis可以实现分布式锁"></a>为什么redis可以实现分布式锁</h2><p>redis是单进程单线程模式，<strong>（只是在处理网络请求的时候只有一个线程来处理）</strong>，采用队列模式将并发访问变成串行访问，reids采用多路 I/O 复用模型（<strong>链接多个客户端，复用同一个线程</strong>），多客户端对reids的连接不存在竞争关系。因为不会产生并发，它的安全性就是很好的。</p><h2 id="reids实现锁的关键命令"><a href="#reids实现锁的关键命令" class="headerlink" title="reids实现锁的关键命令"></a>reids实现锁的关键命令</h2><p>当第一个方法运行，需要加锁，让其他请求知道方法正在运行，你不能进来了，那什么命令有这样的功能呢？<br><br>大家有没有这样的想法，先set key value 等方法结束了再del,这样下一个线程get key 为null的时候就可以获得锁了。但是这样的开发代码量就比较多了，不是很爽，而且如果当方法出现bug,会导致死锁。终于在我不懈努力下让我找到了SETNX（SET if Not eXists） 命令。<br>很简单setnx key value 如果key存在则返回0则覆盖失败，如果不存在则返回1进行set，不需要先get,再set这样复杂的判断。</p><h2 id="需要注意的事项"><a href="#需要注意的事项" class="headerlink" title="需要注意的事项"></a>需要注意的事项</h2><ol><li>死锁怎么办？</li><li>锁不能阻塞怎么办？</li><li>锁不能重入怎么办？</li><li>怎么保证原子性<br><br><strong>解决方案:</strong></li></ol><ul><li>设置失效时间</li><li>while 重复执行</li><li>将当前主机信息和线程信息保存起来，下次获取之前先检查自己是不是当前锁的拥有者。</li><li>使用lua脚本语言（redis运行lua脚本，就相当于一个命令，只会有一个线程在运行这个脚本直到结束。）</li></ul><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>设置失效时间有几个问题，第一个时间过长需要等待，时间过短有可能方法还没有运行完锁就释放了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>1.常量设置</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//锁成功后的返回结果</span><br><span class="line">private static final String LOCK_SUCCESS = &quot;OK&quot;;</span><br><span class="line">   // 这个参数我们填的是NX，</span><br><span class="line">   // 意思是SET IF NOT EXIST，</span><br><span class="line">   // 即当key不存在时，我们进行set操作；</span><br><span class="line">   // 若key已经存在，则不做任何操作；相当于setnx()</span><br><span class="line">   private static final String SET_IF_NOT_EXIST = &quot;NX&quot;;</span><br><span class="line">   //设置超时时间</span><br><span class="line">   private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;;</span><br><span class="line">   //设置返回成功常量</span><br><span class="line">   private static final Long RELEASE_SUCCESS = 1L;</span><br><span class="line">   //设置存活时间</span><br><span class="line">   private static final int EXIT_TIME = 3 * 1000;</span><br><span class="line">   //默认睡眠时间</span><br><span class="line">   private static final int DEFAULT_SLEEP_TIME = 1000;</span><br><span class="line">   //默认每次循环时间减少量</span><br><span class="line">   private static final int DEFAULT_BLOCK_LOOP = 100;</span><br></pre></td></tr></table></figure></code></pre><p>2.加锁方法</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * requestId可以设置为client的唯一标识可用UUID.randomUUID().toString()生成</span><br><span class="line">    * 设置锁,setnx()需要设置存在时间</span><br><span class="line">    *</span><br><span class="line">    * @param lockKey</span><br><span class="line">    * @param requestId</span><br><span class="line">    */</span><br><span class="line">   public static boolean setNXLock(String lockKey, String requestId) &#123;</span><br><span class="line">       String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, EXIT_TIME);</span><br><span class="line">       if (result != null &amp;&amp; result.equals(LOCK_SUCCESS)) &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre><p>3.解锁方法</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 使用lua脚本实现 删除del</span><br><span class="line">   *</span><br><span class="line">   * @param lockKey</span><br><span class="line">   * @param requestId</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public synchronized static boolean releaseLock(String lockKey, String requestId) &#123;</span><br><span class="line">      //lua语言。保证原子性</span><br><span class="line">      String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">      Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">      if (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre><p>3.错误的阻塞加锁方法</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 这样写有个缺陷是有可能会导致线程饥饿</span><br><span class="line">     * 所以我们需要通过指定一个时间循环</span><br><span class="line">     * 而且还会让CPU 一直消耗</span><br><span class="line">     *</span><br><span class="line">     * @param lockKey</span><br><span class="line">     * @param requestId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public synchronized static boolean lock(String lockKey, String requestId) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (setNXLock(lockKey, requestId)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><p>4.正确的阻塞加锁方法</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * blockTime建议根据实际方法运算时间设置</span><br><span class="line">    *</span><br><span class="line">    * @param lockKey</span><br><span class="line">    * @param requestId</span><br><span class="line">    * @param blockTime</span><br><span class="line">    * @return</span><br><span class="line">    * @throws InterruptedException</span><br><span class="line">    */</span><br><span class="line">   public synchronized static boolean lock(String lockKey, String requestId, int blockTime) throws InterruptedException &#123;</span><br><span class="line">       while (blockTime &gt; 0) &#123;</span><br><span class="line">           if (setNXLock(lockKey, requestId)) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           //随机产生睡眠时间，减少并发访问</span><br><span class="line">           Thread.sleep((long) (Math.random() * DEFAULT_SLEEP_TIME));</span><br><span class="line">           blockTime -= DEFAULT_BLOCK_LOOP;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre><p>4.测试方案一</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">           final String finalI = Integer.toString(i);</span><br><span class="line">           new Thread(new Runnable() &#123;</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       Thread.currentThread().setName(&quot;test&quot;+finalI);</span><br><span class="line">                       String key = &quot;TestRedisPower&quot;;</span><br><span class="line">                       String value = finalI;</span><br><span class="line">                       boolean testRedisPower = JedisDistributLockUtil.lock(key,value ,  1000);</span><br><span class="line">                       if(testRedisPower)&#123;</span><br><span class="line">                           Thread.sleep((long) (Math.random() * 1000));</span><br><span class="line">                           System.out.println(Thread.currentThread().getName()+&quot;处理成功&quot;);</span><br><span class="line">                           boolean b = JedisDistributLockUtil.releaseLock(key, value);</span><br><span class="line">                       &#125;else&#123;</span><br><span class="line">                           System.out.println(Thread.currentThread().getName()+&quot;处理失败&quot;);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre><p>运行结果<br><img src="https://wuzhiwen.oss-cn-beijing.aliyuncs.com/1B09E1F4-FF7E-4a5a-B773-18FED3A440B4.png" alt=""><br>看到了test6处理失败，原因很简单就是blockTime设置时间太短造成的，所以我们对时间的设置需要进行测试。</p><p>4.测试方案二</p><hr><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">           final String finalI = Integer.toString(i);</span><br><span class="line">           new Thread(new Runnable() &#123;</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       Thread.currentThread().setName(&quot;test&quot;+finalI);</span><br><span class="line">                       String key = &quot;TestRedisPower&quot;;</span><br><span class="line">                       String value = finalI;</span><br><span class="line">                       boolean testRedisPower = JedisDistributLockUtil.lock(key,value , 10 * 1000);</span><br><span class="line">                       if(testRedisPower)&#123;</span><br><span class="line">                           System.out.println(Thread.currentThread().getName()+&quot;处理成功&quot;);</span><br><span class="line">                           boolean b = JedisDistributLockUtil.releaseLock(key, value);</span><br><span class="line">                       &#125;else&#123;</span><br><span class="line">                           System.out.println(Thread.currentThread().getName()+&quot;处理失败&quot;);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre><p>运行结果是都成功了，不过很慢，大家也可以设置一个缓存池，把synchronized去了，看看效率是不是会高点，代码就需要大家自己改造了。<br><a href="https://gitee.com/ZuiJi/distributed.git" target="_blank" rel="noopener">代码地址</a></p><p><a href="https://segmentfault.com/a/1190000014128432" title="写的比我好" target="_blank" rel="noopener">写的比我好</a><br><a href="https://yq.aliyun.com/ziliao/311007?spm=a2c4e.11155472.blogcont.14.6e7144afYJP5VL" title="redis集群时DML思路" target="_blank" rel="noopener">redis集群时DML思路</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式锁 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
